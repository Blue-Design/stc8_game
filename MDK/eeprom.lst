C51 COMPILER V9.60.0.0   EEPROM                                                            01/08/2021 19:05:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Out_File\eeprom.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Device\eeprom.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Device;..\Li
                    -braries;..\User) DEBUG OBJECTEXTEND PRINT(.\eeprom.lst) OBJECT(.\Out_File\eeprom.obj)

line level    source

   1          #include "eeprom.h"
   2          
   3          //========================================================================
   4          // 描述: 禁止EEPROM.
   5          // 参数: none.
   6          // 返回: none.
   7          //========================================================================
   8          void eeprom_disable(void)        //禁止访问EEPROM
   9          {
  10   1                      IAP_CONTR = 0;          //关闭 IAP 功能
  11   1                      IAP_CMD = 0;            //清除命令寄存器
  12   1                      IAP_TRIG = 0;           //清除触发寄存器
  13   1                      IAP_ADDRH = 0xff;       //将地址设置到非 IAP 区域
  14   1                      IAP_ADDRL = 0xff;
  15   1      }
  16          
  17          //========================================================================
  18          // 描述: 触发EEPROM操作.
  19          // 参数: none.
  20          // 返回: none.
  21          //========================================================================
  22          void eeprom_trig(void)
  23          {
  24   1          F0 = EA;    //保存全局中断
  25   1          EA = 0;     //禁止中断, 避免触发命令无效
  26   1          IAP_TRIG = 0x5A;
  27   1          IAP_TRIG = 0xA5;                    //先送5AH，再送A5H到IAP触发寄存器，每次都需要如此
  28   1                                              //送完A5H后，IAP命令立即被触发启动
  29   1                                              //CPU等待IAP完成后，才会继续执行程序。
  30   1          _nop_();
  31   1          _nop_();
  32   1          EA = F0;    //恢复全局中断
  33   1      }
  34          
  35          //========================================================================
  36          // 描述: 擦除一个扇区.
  37          // 参数: EE_address:  要擦除的EEPROM的扇区中的一个字节地址.
  38          // 返回: none.
  39          //========================================================================
  40          void eeprom_sector_erase(uint16 EE_address)
  41          {
  42   1          EEPROM_IAP_ENABLE();                       //设置等待时间，允许IAP操作，送一次就够
  43   1          EEPROM_IAP_ERASE();                        //宏调用, 送扇区擦除命令，命令不需改变时，不需重新送命令
  44   1                                              //只有扇区擦除，没有字节擦除，512字节/扇区。
  45   1                                              //扇区中任意一个字节地址都是扇区地址。
  46   1          IAP_ADDRH = EE_address / 256;       //送扇区地址高字节（地址需要改变时才需重新送地址）
  47   1          IAP_ADDRL = EE_address % 256;       //送扇区地址低字节
  48   1          eeprom_trig();                      //触发EEPROM操作
  49   1          eeprom_disable();                    //禁止EEPROM操作
  50   1      }
  51          
  52          //========================================================================
  53          // 描述: 读N个字节函数.
  54          // 参数: EE_address:  要读出的EEPROM的首地址.
C51 COMPILER V9.60.0.0   EEPROM                                                            01/08/2021 19:05:40 PAGE 2   

  55          //       DataAddress: 要读出数据的指针.
  56          //       length:      要读出的长度
  57          // 返回: 0: 写入正确.  1: 写入长度为0错误.  2: 写入数据错误.
  58          //========================================================================
  59          void eeprom_read(uint16 EE_address,uint8 *DataAddress,uint8 length)
  60          {
  61   1          EEPROM_IAP_ENABLE();                           //设置等待时间，允许IAP操作，送一次就够
  62   1          EEPROM_IAP_READ();                             //送字节读命令，命令不需改变时，不需重新送命令
  63   1          do
  64   1          {
  65   2              IAP_ADDRH = EE_address / 256;       //送地址高字节（地址需要改变时才需重新送地址）
  66   2              IAP_ADDRL = EE_address % 256;       //送地址低字节
  67   2              eeprom_trig();                      //触发EEPROM操作
  68   2              *DataAddress = IAP_DATA;            //读出的数据送往
  69   2              EE_address++;
  70   2              DataAddress++;
  71   2          }while(--length);
  72   1      
  73   1          eeprom_disable();
  74   1      }
  75          
  76          //========================================================================
  77          // 描述: 写N个字节函数.
  78          // 参数: EE_address:  要写入的EEPROM的首地址.
  79          //       DataAddress: 要写入数据的指针.
  80          //       length:      要写入的长度
  81          // 返回: 0: 写入正确.  1: 写入长度为0错误.  2: 写入数据错误.
  82          //========================================================================
  83          uint8 eeprom_write(uint16 EE_address,uint8 *DataAddress,uint8 length)
  84          {
  85   1          uint8  i;
  86   1          uint16 j;
  87   1          uint8  *p;
  88   1          
  89   1          if(length == 0) return 1;   //长度为0错误
  90   1      
  91   1          EEPROM_IAP_ENABLE();                       //设置等待时间，允许IAP操作，送一次就够
  92   1          i = length;
  93   1          j = EE_address;
  94   1          p = DataAddress;
  95   1          EEPROM_IAP_WRITE();                            //宏调用, 送字节写命令
  96   1          do
  97   1          {
  98   2              IAP_ADDRH = EE_address / 256;       //送地址高字节（地址需要改变时才需重新送地址）
  99   2              IAP_ADDRL = EE_address % 256;       //送地址低字节
 100   2              IAP_DATA  = *DataAddress;           //送数据到IAP_DATA，只有数据改变时才需重新送
 101   2              eeprom_trig();                      //触发EEPROM操作
 102   2              EE_address++;                       //下一个地址
 103   2              DataAddress++;                      //下一个数据
 104   2          }while(--length);                       //直到结束
 105   1      
 106   1          EE_address = j;
 107   1          length = i;
 108   1          DataAddress = p;
 109   1          i = 0;
 110   1          EEPROM_IAP_READ();                             //读N个字节并比较
 111   1          do
 112   1          {
 113   2              IAP_ADDRH = EE_address / 256;       //送地址高字节（地址需要改变时才需重新送地址）
 114   2              IAP_ADDRL = EE_address % 256;       //送地址低字节
 115   2              eeprom_trig();                      //触发EEPROM操作
 116   2              if(*DataAddress != IAP_DATA)        //读出的数据与源数据比较
C51 COMPILER V9.60.0.0   EEPROM                                                            01/08/2021 19:05:40 PAGE 3   

 117   2              {
 118   3                  i = 2;
 119   3                  break;
 120   3              }
 121   2              EE_address++;
 122   2              DataAddress++;
 123   2          }while(--length);
 124   1      
 125   1          eeprom_disable();
 126   1          return i;
 127   1      }
 128          
 129          //========================================================================
 130          // 描述: 从EEPROM中读浮点型数据.
 131          // 参数: EE_address:要读取的地址.
 132          // 返回: 读到的float数据.
 133          //========================================================================
 134          float eeprom_read_float(uint16 EE_address)
 135          {
 136   1              float dat;
 137   1              eeprom_read(EE_address,(uint8 *)&dat,sizeof(float));
 138   1              return dat;
 139   1      }
 140          
 141          //========================================================================
 142          // 描述: 从EEPROM中写浮点型数据.
 143          // 参数: EE_address:要读取的地址; dat:要写入的float数据.
 144          // 返回: none.
 145          //========================================================================
 146          void eeprom_write_float(uint16 EE_address, float dat)
 147          {       
 148   1              eeprom_write(EE_address,(uint8 *)&dat,sizeof(float));
 149   1      }
 150          
 151          //========================================================================
 152          // 描述: 从EEPROM中读int数据.
 153          // 参数: EE_address:要读取的地址.
 154          // 返回: 读到的float数据.
 155          //========================================================================
 156          int eeprom_read_int(uint16 EE_address)
 157          {
 158   1              int dat;
 159   1              eeprom_read(EE_address,(uint8 *)&dat,sizeof(int));
 160   1              return dat;
 161   1      }
 162          
 163          //========================================================================
 164          // 描述: 从EEPROM中写int数据.
 165          // 参数: EE_address:要读取的地址; dat:要写入的float数据.
 166          // 返回: none.
 167          //========================================================================
 168          void eeprom_write_int(uint16 EE_address, int dat)
 169          {       
 170   1              eeprom_write(EE_address, (uint8 *)&dat,sizeof(int));
 171   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    568    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      33
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   EEPROM                                                            01/08/2021 19:05:40 PAGE 4   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
