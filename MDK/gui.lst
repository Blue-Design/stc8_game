C51 COMPILER V9.60.0.0   GUI                                                               01/08/2021 19:05:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GUI
OBJECT MODULE PLACED IN .\Out_File\gui.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Device\gui.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Device;..\Libra
                    -ries;..\User) DEBUG OBJECTEXTEND PRINT(.\gui.lst) OBJECT(.\Out_File\gui.obj)

line level    source

   1          #include "gui.h"
   2          
   3          //画圆形指针表盘
   4          //x，y坐标中心点
   5          //size:表盘大小
   6          //d:表盘分割，秒钟的高度
   7          void calendar_circle_clock_drawpanel(uint16 x,uint16 y,uint16 size,uint16 d)
   8          {
   9   1              uint16 r=size/2;//得到半径
  10   1              uint16 sx=x-r;
  11   1              uint16 sy=y-r;
  12   1              uint16 px0,px1;
  13   1              uint16 py0,py1; 
  14   1              uint16 i;
  15   1      
  16   1              tft_lcd_draw_circle(x, y, r, TFT_LCD_WHITE, 1);
  17   1              tft_lcd_draw_circle(x, y, r-4, TFT_LCD_BLACK, 1);
  18   1      
  19   1              for(i=0;i<60;i++)   //画秒钟格
  20   1              { 
  21   2                      px0=sx+r+(r-4)*sin((app_pi/30)*i); 
  22   2                      py0=sy+r-(r-4)*cos((app_pi/30)*i); 
  23   2                      px1=sx+r+(r-d)*sin((app_pi/30)*i); 
  24   2                      py1=sy+r-(r-d)*cos((app_pi/30)*i);  
  25   2                      tft_lcd_draw_line1(px0,py0,px1,py1,0, TFT_LCD_WHITE);
  26   2              }
  27   1              for(i=0;i<12;i++)   //画小时格
  28   1              { 
  29   2                      px0=sx+r+(r-5)*sin((app_pi/6)*i); 
  30   2                      py0=sy+r-(r-5)*cos((app_pi/6)*i); 
  31   2                      px1=sx+r+(r-d)*sin((app_pi/6)*i); 
  32   2                      py1=sy+r-(r-d)*cos((app_pi/6)*i);  
  33   2                      tft_lcd_draw_line1(px0,py0,px1,py1,2, TFT_LCD_YELLOW);
  34   2              }
  35   1              for(i=0;i<4;i++)    //画3小时格
  36   1              { 
  37   2                      px0=sx+r+(r-5)*sin((app_pi/2)*i); 
  38   2                      py0=sy+r-(r-5)*cos((app_pi/2)*i); 
  39   2                      px1=sx+r+(r-d-3)*sin((app_pi/2)*i); 
  40   2                      py1=sy+r-(r-d-3)*cos((app_pi/2)*i);  
  41   2                      tft_lcd_draw_line1(px0,py0,px1,py1,2, TFT_LCD_YELLOW);
  42   2              }
  43   1              //gui_circle(x,y,d/2,WHITE);            //画中心圆
  44   1              tft_lcd_draw_circle(x, y, d/2, TFT_LCD_WHITE, 1);
  45   1      }
  46          
  47          //显示时间
  48          //x,y:坐标中心点
  49          //size: 表盘大小
  50          //d:表盘分割，秒钟高度
  51          //hour:时钟
  52          //min:分钟
  53          //sec:秒钟
  54          void calendar_circle_clock_showtime(uint16 x,uint16 y,uint16 size,uint16 d,uint8 hour,uint8 min,uint8 sec)
C51 COMPILER V9.60.0.0   GUI                                                               01/08/2021 19:05:40 PAGE 2   

  55          {
  56   1              static uint8 oldhour=0; //最近一次进入该函数的时分秒信息
  57   1              static uint8 oldmin=0;
  58   1              static uint8 oldsec=0;
  59   1              float temp;
  60   1              uint16 r=size/2;           //得到半径 
  61   1              uint16 sx=x-r;
  62   1              uint16 sy=y-r;
  63   1              uint16 px0,px1;
  64   1              uint16 py0,py1;  
  65   1              uint8 r1; 
  66   1              if(hour>11)hour-=12;
  67   1      ///////////////////////////////////////////////
  68   1              //清除小时
  69   1              r1=d/2+4;
  70   1              //清除上一次数据
  71   1              temp=(float)oldmin/60;
  72   1              temp+=oldhour;
  73   1              px0=sx+r+(r-3*d-7)*sin((app_pi/6)*temp); 
  74   1              py0=sy+r-(r-3*d-7)*cos((app_pi/6)*temp); 
  75   1              px1=sx+r+r1*sin((app_pi/6)*temp); 
  76   1              py1=sy+r-r1*cos((app_pi/6)*temp); 
  77   1              tft_lcd_draw_line1(px0,py0,px1,py1,2, TFT_LCD_BLACK);
  78   1              //清除分钟
  79   1              r1=d/2+3;
  80   1              temp=(float)oldsec/60;
  81   1              temp+=oldmin;
  82   1              //清除上一次数据
  83   1              px0=sx+r+(r-2*d-7)*sin((app_pi/30)*temp); 
  84   1              py0=sy+r-(r-2*d-7)*cos((app_pi/30)*temp); 
  85   1              px1=sx+r+r1*sin((app_pi/30)*temp); 
  86   1              py1=sy+r-r1*cos((app_pi/30)*temp); 
  87   1              tft_lcd_draw_line1(px0,py0,px1,py1,1, TFT_LCD_BLACK);
  88   1              //清除秒钟
  89   1              r1=d/2+3;
  90   1              //清除上一次数据
  91   1              px0=sx+r+(r-d-7)*sin((app_pi/30)*oldsec); 
  92   1              py0=sy+r-(r-d-7)*cos((app_pi/30)*oldsec); 
  93   1              px1=sx+r+r1*sin((app_pi/30)*oldsec); 
  94   1              py1=sy+r-r1*cos((app_pi/30)*oldsec); 
  95   1              tft_lcd_draw_line1(px0,py0,px1,py1,0, TFT_LCD_BLACK);
  96   1      ///////////////////////////////////////////////
  97   1              //显示小时
  98   1              r1=d/2+4; 
  99   1              //显示新的时钟
 100   1              temp=(float)min/60;
 101   1              temp+=hour;
 102   1              px0=sx+r+(r-3*d-7)*sin((app_pi/6)*temp); 
 103   1              py0=sy+r-(r-3*d-7)*cos((app_pi/6)*temp); 
 104   1              px1=sx+r+r1*sin((app_pi/6)*temp); 
 105   1              py1=sy+r-r1*cos((app_pi/6)*temp); 
 106   1              tft_lcd_draw_line1(px0,py0,px1,py1,2, TFT_LCD_YELLOW);
 107   1              //显示分钟
 108   1              r1=d/2+3; 
 109   1              temp=(float)sec/60;
 110   1              temp+=min;
 111   1              //显示新的分钟
 112   1              px0=sx+r+(r-2*d-7)*sin((app_pi/30)*temp); 
 113   1              py0=sy+r-(r-2*d-7)*cos((app_pi/30)*temp); 
 114   1              px1=sx+r+r1*sin((app_pi/30)*temp); 
 115   1              py1=sy+r-r1*cos((app_pi/30)*temp); 
 116   1              tft_lcd_draw_line1(px0,py0,px1,py1,1, TFT_LCD_GREEN);
C51 COMPILER V9.60.0.0   GUI                                                               01/08/2021 19:05:40 PAGE 3   

 117   1              //显示秒钟
 118   1              r1=d/2+3;
 119   1              //显示新的秒钟
 120   1              px0=sx+r+(r-d-7)*sin((app_pi/30)*sec); 
 121   1              py0=sy+r-(r-d-7)*cos((app_pi/30)*sec); 
 122   1              px1=sx+r+r1*sin((app_pi/30)*sec); 
 123   1              py1=sy+r-r1*cos((app_pi/30)*sec); 
 124   1              tft_lcd_draw_line1(px0,py0,px1,py1,0, TFT_LCD_RED);
 125   1              oldhour=hour;   //保存时
 126   1              oldmin=min;             //保存分
 127   1              oldsec=sec;             //保存秒
 128   1      }           
 129          
 130          //画坐标轴
 131          //x,y中心点位置
 132          //size:轴的间距
 133          //d: 轴的大小
 134          void oscilloscope_axis(uint16 x,uint16 y,uint16 size,uint16 d)
 135          {
 136   1              uint16 px0,px1;
 137   1              uint16 py0,py1;
 138   1              uint16 c1 ,c2;
 139   1      
 140   1              //画X轴
 141   1              px0 = x;
 142   1              py0 = y + d/2;
 143   1              py1 = y - d/2;
 144   1              c1 = y; c2 = y;
 145   1              tft_lcd_draw_line1(px0,py0,px0,py1,1, TFT_LCD_WHITE);   //画X轴中心点
 146   1              while(px0 <= (lcddev.width-size))
 147   1              {
 148   2                      px0 = px0 +size;
 149   2                      tft_lcd_draw_line1(px0,py0,px0,py1,1, TFT_LCD_WHITE);   //画正x半轴
 150   2                      while(c1 <= lcddev.height-size*5)
 151   2                      {
 152   3                              c1 = c1 + size * 5;
 153   3                              tft_lcd_draw_circle(px0, c1, 1, TFT_LCD_WHITE, 1);
 154   3                      }
 155   2                      while(c2 >= size*5)
 156   2                      {
 157   3                              c2 = c2 - size * 5;
 158   3                              tft_lcd_draw_circle(px0, c2,1, TFT_LCD_WHITE,  1);
 159   3                              
 160   3                      }
 161   2                      c1 = y;
 162   2                      c2 = y;
 163   2              }
 164   1      
 165   1              while(px0 >= size){
 166   2                      px0 = px0 - size;
 167   2                      tft_lcd_draw_line1(px0,py0,px0,py1,1, TFT_LCD_WHITE);   //画负x半轴
 168   2                      while(c1 <= lcddev.height-size*5)
 169   2                      {
 170   3                              c1 = c1 + size * 5;
 171   3                              tft_lcd_draw_circle(px0, c1, 1, TFT_LCD_WHITE,  1);
 172   3                              
 173   3                      }
 174   2                      while(c2 >= size*5)
 175   2                      {
 176   3                              c2 = c2 - size * 5;
 177   3                              tft_lcd_draw_circle(px0, c2, 1, TFT_LCD_WHITE, 1);
 178   3                              
C51 COMPILER V9.60.0.0   GUI                                                               01/08/2021 19:05:40 PAGE 4   

 179   3                      }
 180   2                      c1 = y;
 181   2                      c2 = y;
 182   2              }
 183   1      
 184   1              //画y轴
 185   1              py0 = y;
 186   1              px0 = x + d/2;
 187   1              px1 = x - d/2;
 188   1              c1 = x; c2 = x;
 189   1              tft_lcd_draw_line1(px0,py0,px1,py0,1, TFT_LCD_WHITE);   //画Y轴中心点
 190   1              while(py0 <= lcddev.height-size)
 191   1              {
 192   2                      py0 = py0 +size;
 193   2                      tft_lcd_draw_line1(px0,py0,px1,py0,1, TFT_LCD_WHITE);   //画正Y半轴
 194   2                      while(c1 <= lcddev.width-size*5)
 195   2                      {
 196   3                              c1 = c1 + size * 5;
 197   3                              tft_lcd_draw_circle(c1, py0, 1, TFT_LCD_WHITE, 1);
 198   3                              
 199   3                      }
 200   2                      while(c2 >= size*5)
 201   2                      {       
 202   3                              c2 = c2 - size * 5;
 203   3                              tft_lcd_draw_circle(c2, py0, 1, TFT_LCD_WHITE, 1);
 204   3                      }
 205   2                      c1 = x;
 206   2                      c2 = x;
 207   2              }
 208   1      
 209   1              while(py0 >= size){
 210   2                      py0 = py0 - size;
 211   2                      tft_lcd_draw_line1(px0,py0,px1,py0,1, TFT_LCD_WHITE);   //画负Y半轴
 212   2                      while(c1 <= lcddev.width-size*5)
 213   2                      {
 214   3                              c1 = c1 + size * 5;
 215   3                              tft_lcd_draw_circle(c1, py0, 1, TFT_LCD_WHITE, 1);
 216   3                              
 217   3                      }
 218   2                      while(c2 >= size*5)
 219   2                      {
 220   3                              c2 = c2 - size*5;
 221   3                              tft_lcd_draw_circle(c2, py0, 1, TFT_LCD_WHITE, 1);
 222   3                      }
 223   2                      c1 = x;
 224   2                      c2 = x;
 225   2              }
 226   1      }
 227          
 228          //画正弦函数
 229          void oscilloscope_sin()
 230          {
 231   1              uint16 i,tem_color;
 232   1              int y;
 233   1              int k;
 234   1              tem_color = _tft_lcd_point_color;
 235   1              for(i=0; i<339;i++){
 236   2                      y = 30*sin(i/20.0);
 237   2                      _tft_lcd_point_color = TFT_LCD_YELLOW;
 238   2                      tft_lcd_draw_point((u16)y+161,i);
 239   2                      tft_lcd_draw_point((u16)y+160,i);
 240   2                      tft_lcd_draw_point((u16)y+159,i);
C51 COMPILER V9.60.0.0   GUI                                                               01/08/2021 19:05:40 PAGE 5   

 241   2      
 242   2                      k = 30*cos(i/20.0);
 243   2                      _tft_lcd_point_color = TFT_LCD_GBLUE;
 244   2                      tft_lcd_draw_point((u16)k+41,i);
 245   2                      tft_lcd_draw_point((u16)k+40,i);
 246   2                      tft_lcd_draw_point((u16)k+39,i);
 247   2                      delay(10);
 248   2              }
 249   1              _tft_lcd_point_color = tem_color;
 250   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7354    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3      82
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
