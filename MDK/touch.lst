C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TOUCH
OBJECT MODULE PLACED IN .\Out_File\touch.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Device\touch.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Device;..\Lib
                    -raries;..\User) DEBUG OBJECTEXTEND PRINT(.\touch.lst) OBJECT(.\Out_File\touch.obj)

line level    source

   1          #include "touch.h"
   2          
   3          //========================================================================
   4          // 描述: 读取X坐标.
   5          // 参数: none.
   6          // 返回: 读到的坐标.
   7          //========================================================================
   8          uint16 touch_read_raw_x()
   9          {
  10   1              uint16 i, j;
  11   1              uint16 buf[TOUCH_READ_TIMES];
  12   1              uint16 sum=0;
  13   1              uint16 temp;
  14   1              if(lcddev.id == 0x9341)
  15   1              {
  16   2                      LCD9341_SET_XM_OUT;
  17   2                      LCD9341_SET_XP_OUT;
  18   2                      LCD9341_SET_YP_IN;   
  19   2                      LCD9341_SET_YM_IN;
  20   2                      LCD9341_TOUCH_XP_PIN = 1;
  21   2                      LCD9341_TOUCH_YP_PIN = 0;
  22   2                      LCD9341_TOUCH_YM_PIN = 0;
  23   2                      LCD9341_TOUCH_XM_PIN = 0;
  24   2                      adc_init(LCD9341_YP_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
  25   2                      for(i=0;i<TOUCH_READ_TIMES;i++)buf[i]=adc_read(LCD9341_YP_ADC_PIN);                 
  26   2                      for(i=0;i<TOUCH_READ_TIMES-1; i++)//排序
  27   2                      {
  28   3                              for(j=i+1;j<TOUCH_READ_TIMES;j++)
  29   3                              {
  30   4                                      if(buf[i]>buf[j])//升序排列
  31   4                                      {
  32   5                                              temp=buf[i];
  33   5                                              buf[i]=buf[j];
  34   5                                              buf[j]=temp;
  35   5                                      }
  36   4                              }
  37   3                      }        
  38   2                      sum=0;
  39   2                      for(i=TOUCH_LOST_VAL;i<TOUCH_READ_TIMES-TOUCH_LOST_VAL;i++)sum+=buf[i];
  40   2                      temp=sum/(TOUCH_READ_TIMES-2*TOUCH_LOST_VAL);
  41   2                      LCD9341_SET_YP_OUT;
  42   2                      LCD9341_SET_YM_OUT;
  43   2                      return temp;
  44   2              }
  45   1              else
  46   1              {
  47   2                      SM245_SET_XM_OUT;
  48   2                      SM245_SET_XP_OUT;
  49   2                      SM245_SET_YP_IN;   
  50   2                      SM245_SET_YM_IN;
  51   2                      SM245_TOUCH_XP_PIN = 1;
  52   2                      SM245_TOUCH_YP_PIN = 0;
  53   2                      SM245_TOUCH_YM_PIN = 0;
  54   2                      SM245_TOUCH_XM_PIN = 0;
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 2   

  55   2                      adc_init(SM245_YP_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
  56   2                      for(i=0;i<TOUCH_READ_TIMES;i++)buf[i]=adc_read(SM245_YP_ADC_PIN);                   
  57   2                      for(i=0;i<TOUCH_READ_TIMES-1; i++)//排序
  58   2                      {
  59   3                              for(j=i+1;j<TOUCH_READ_TIMES;j++)
  60   3                              {
  61   4                                      if(buf[i]>buf[j])//升序排列
  62   4                                      {
  63   5                                              temp=buf[i];
  64   5                                              buf[i]=buf[j];
  65   5                                              buf[j]=temp;
  66   5                                      }
  67   4                              }
  68   3                      }        
  69   2                      sum=0;
  70   2                      for(i=TOUCH_LOST_VAL;i<TOUCH_READ_TIMES-TOUCH_LOST_VAL;i++)sum+=buf[i];
  71   2                      temp=sum/(TOUCH_READ_TIMES-2*TOUCH_LOST_VAL);
  72   2                      SM245_SET_YP_OUT;
  73   2                      SM245_SET_YM_OUT;
  74   2                      return temp;
  75   2              }
  76   1      }
  77          
  78          //========================================================================
  79          // 描述: 读取Y坐标.
  80          // 参数: none.
  81          // 返回: 读到的坐标.
  82          //========================================================================
  83          uint16 touch_read_raw_y()
  84          {
  85   1              uint16 i, j;
  86   1              uint16 buf[TOUCH_READ_TIMES];
  87   1              uint16 sum=0;
  88   1              uint16 temp;
  89   1              if(lcddev.id == 0x9341)
  90   1              {
  91   2                      LCD9341_SET_YP_OUT;
  92   2                      LCD9341_SET_YM_OUT;
  93   2                      LCD9341_SET_XP_IN;   
  94   2                      LCD9341_SET_XM_IN;
  95   2                      LCD9341_TOUCH_YP_PIN = 1;
  96   2                      LCD9341_TOUCH_YM_PIN = 0;
  97   2                      LCD9341_TOUCH_XP_PIN = 0;
  98   2                      LCD9341_TOUCH_XM_PIN = 0;
  99   2              
 100   2                      adc_init(LCD9341_XM_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
 101   2      
 102   2                      for(i=0;i<TOUCH_READ_TIMES;i++)buf[i]=adc_read(LCD9341_XM_ADC_PIN);                 
 103   2                      for(i=0;i<TOUCH_READ_TIMES-1; i++)//排序
 104   2                      {
 105   3                              for(j=i+1;j<TOUCH_READ_TIMES;j++)
 106   3                              {
 107   4                                      if(buf[i]>buf[j])//升序排列
 108   4                                      {
 109   5                                              temp=buf[i];
 110   5                                              buf[i]=buf[j];
 111   5                                              buf[j]=temp;
 112   5                                      }
 113   4                              }
 114   3                      }        
 115   2                      sum=0;
 116   2                      for(i=TOUCH_LOST_VAL;i<TOUCH_READ_TIMES-TOUCH_LOST_VAL;i++)sum+=buf[i];
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 3   

 117   2                      temp=sum/(TOUCH_READ_TIMES-2*TOUCH_LOST_VAL);
 118   2                      LCD9341_SET_XM_OUT;
 119   2                      LCD9341_SET_XP_OUT;
 120   2                      return temp;
 121   2              }
 122   1              else
 123   1              {
 124   2                      SM245_SET_YP_OUT;
 125   2                      SM245_SET_YM_OUT;
 126   2                      SM245_SET_XP_IN;   
 127   2                      SM245_SET_XM_IN;
 128   2                      SM245_TOUCH_YP_PIN = 1;
 129   2                      SM245_TOUCH_YM_PIN = 0;
 130   2                      SM245_TOUCH_XP_PIN = 0;
 131   2                      SM245_TOUCH_XM_PIN = 0;
 132   2              
 133   2                      adc_init(SM245_XM_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
 134   2      
 135   2                      for(i=0;i<TOUCH_READ_TIMES;i++)buf[i]=adc_read(SM245_XM_ADC_PIN);                   
 136   2                      for(i=0;i<TOUCH_READ_TIMES-1; i++)//排序
 137   2                      {
 138   3                              for(j=i+1;j<TOUCH_READ_TIMES;j++)
 139   3                              {
 140   4                                      if(buf[i]>buf[j])//升序排列
 141   4                                      {
 142   5                                              temp=buf[i];
 143   5                                              buf[i]=buf[j];
 144   5                                              buf[j]=temp;
 145   5                                      }
 146   4                              }
 147   3                      }        
 148   2                      sum=0;
 149   2                      for(i=TOUCH_LOST_VAL;i<TOUCH_READ_TIMES-TOUCH_LOST_VAL;i++)sum+=buf[i];
 150   2                      temp=sum/(TOUCH_READ_TIMES-2*TOUCH_LOST_VAL);
 151   2                      SM245_SET_XM_OUT;
 152   2                      SM245_SET_XP_OUT;
 153   2                      return temp;
 154   2              }
 155   1      }
 156          
 157          //========================================================================
 158          // 描述: 读取触摸的压力值.
 159          // 参数: none.
 160          // 返回: 读到的压力值.
 161          //========================================================================
 162          uint16 touch_read_pressure()
 163          {
 164   1          int z1,z2;
 165   1              if(lcddev.id == 0x9341)
 166   1              {
 167   2                      LCD9341_SET_XP_OUT;
 168   2                      LCD9341_SET_YM_OUT;
 169   2                      LCD9341_SET_XM_IN;
 170   2                      LCD9341_SET_YP_IN;
 171   2                      LCD9341_TOUCH_XP_PIN = 0;
 172   2                      LCD9341_TOUCH_YM_PIN = 1; 
 173   2                      LCD9341_TOUCH_XM_PIN = 0;
 174   2                      LCD9341_TOUCH_YP_PIN = 0;
 175   2      
 176   2                      adc_init(LCD9341_XM_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
 177   2                      adc_init(LCD9341_YP_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
 178   2      
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 4   

 179   2                      z1 = adc_read(LCD9341_XM_ADC_PIN); 
 180   2                      z2 = adc_read(LCD9341_YP_ADC_PIN);
 181   2      
 182   2                      LCD9341_SET_XM_OUT;
 183   2                      LCD9341_SET_YP_OUT;
 184   2                      LCD9341_TOUCH_YP_PIN = 1;
 185   2                      LCD9341_TOUCH_XM_PIN = 1;
 186   2                      return (4095 - (z2-z1));
 187   2              }
 188   1              else
 189   1              {
 190   2                      SM245_SET_XP_OUT;
 191   2                      SM245_SET_YM_OUT;
 192   2                      SM245_SET_XM_IN;
 193   2                      SM245_SET_YP_IN;
 194   2                      SM245_TOUCH_XP_PIN = 0;
 195   2                      SM245_TOUCH_YM_PIN = 1; 
 196   2                      SM245_TOUCH_XM_PIN = 0;
 197   2                      SM245_TOUCH_YP_PIN = 0;
 198   2      
 199   2                      adc_init(SM245_XM_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
 200   2                      adc_init(SM245_YP_ADC_PIN, ADC_SYSclk_DIV_2, ADC_12BIT);
 201   2      
 202   2                      z1 = adc_read(SM245_XM_ADC_PIN); 
 203   2                      z2 = adc_read(SM245_YP_ADC_PIN);
 204   2      
 205   2                      SM245_SET_XM_OUT;
 206   2                      SM245_SET_YP_OUT;
 207   2                      SM245_TOUCH_YP_PIN = 1;
 208   2                      SM245_TOUCH_XM_PIN = 1;
 209   2                      return (4095 - (z2-z1));
 210   2              }
 211   1      }
 212          
 213          //========================================================================
 214          // 描述: 通过2次采样误差得到更准确的坐标值.
 215          // 参数: x,y:采样得到的物理坐标.
 216          // 返回: 误差在50以内返回1，否则返回0.
 217          //========================================================================
 218          #define ERR_RANGE       50      //误差范围 
 219          uint8 tp_read_xy2(uint16 *x,uint16 *y) 
 220          {
 221   1              uint16 x1,y1;
 222   1              uint16 x2,y2;
 223   1      
 224   1              x1 = touch_read_raw_x();
 225   1              y1 = touch_read_raw_y();
 226   1              x2 = touch_read_raw_x();
 227   1              y2 = touch_read_raw_y();
 228   1      
 229   1          if(((x2<=x1&&x1<x2+ERR_RANGE)||(x1<=x2&&x2<x1+ERR_RANGE))//前后2次采样误差在50以内
 230   1          &&((y2<=y1&&y1<y2+ERR_RANGE)||(y1<=y2&&y2<y1+ERR_RANGE)))
 231   1          {
 232   2              *x=(x1+x2)/2;
 233   2              *y=(y1+y2)/2;
 234   2              return 1;
 235   2          }else return 0;       
 236   1      } 
 237          
 238          //========================================================================
 239          // 描述: 画一个触摸点.
 240          // 参数: x,y:坐标; color:颜色值.
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 5   

 241          // 返回: none.
 242          //========================================================================
 243          void tp_drow_touch_point(uint16 x,uint16 y,uint16 color)
 244          {
 245   1              _tft_lcd_point_color = color;
 246   1              tft_lcd_draw_line(x-12,y,x+13,y,color);    //横线
 247   1              tft_lcd_draw_line(x,y-12,x,y+13,color);    //竖线
 248   1              tft_lcd_draw_point(x+1,y+1);
 249   1              tft_lcd_draw_point(x-1,y+1);
 250   1              tft_lcd_draw_point(x+1,y-1);
 251   1              tft_lcd_draw_point(x-1,y-1);
 252   1              tft_lcd_draw_circle(x,y,6,color,0);         //画中心圈
 253   1      }
 254          
 255          //触摸屏控制器
 256          typedef struct
 257          {               
 258                  uint16 x;       
 259                  uint16 y;               
 260                  uint8  sta;                             
 261              /////////////////////触摸屏校准参数//////////////////////                                                           
 262                  float xfac;                                     
 263                  float yfac;
 264                  int xoff;
 265                  int yoff;          
 266          
 267                  uint8 touchtype;        //屏幕方向
 268          }_m_tp_dev;
 269          
 270          _m_tp_dev tp_dev=
 271          {
 272                  0,
 273                  0, 
 274                  0,
 275                  0,
 276                  0,
 277                  0,                              
 278                  0,
 279                  0                               
 280          };
 281          
 282          //========================================================================
 283          // 描述: 触摸校准程序.
 284          // 参数: none.
 285          // 返回: none.
 286          //========================================================================
 287          void touch_adjust()
 288          {
 289   1              uint16 pos_temp[4][2];//坐标缓冲值
 290   1              uint8  cnt=0;   
 291   1              uint16 d1,d2;
 292   1              uint32 tem1,tem2;
 293   1              float fac;      
 294   1              uint16 outtime=0;
 295   1              cnt=0;                          
 296   1              _tft_lcd_point_color=TFT_LCD_BLUE;
 297   1              _tft_lcd_back_color =TFT_LCD_WHITE;
 298   1              tft_lcd_clear(TFT_LCD_WHITE);   //清屏 
 299   1              _tft_lcd_point_color=TFT_LCD_RED;    //红色
 300   1              tft_lcd_clear(TFT_LCD_WHITE);   //清屏   
 301   1              _tft_lcd_point_color=TFT_LCD_BLACK;
 302   1              tft_lcd_show_string(70,40,"touch adjust",TFT_LCD_RED,TFT_LCD_WHITE,16,1);//显示提示信息
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 6   

 303   1              tp_drow_touch_point(20,20,TFT_LCD_RED);     //画点1
 304   1              tp_dev.sta=0;       //消除触发信号 
 305   1              tp_dev.xfac=0;      //xfac清除校准标志  
 306   1          while(1)            //如果连续10s没有按下，则自动退出
 307   1          {
 308   2              if( tp_read_xy2(&tp_dev.x,&tp_dev.y) && touch_read_pressure() > 100)     //代表有按键按下
 309   2              {
 310   3                  outtime = 0;
 311   3                      tp_dev.sta=1;       //标记按键已经被处理过了
 312   3      
 313   3                              if(lcddev.id == 0x9341)
 314   3                              {
 315   4                                      pos_temp[cnt][0] = tp_dev.y;
 316   4                                      pos_temp[cnt][1] = tp_dev.x;            
 317   4                              }
 318   3                              else if(lcddev.id == 0x9340)
 319   3                              {
 320   4                                      pos_temp[cnt][0] = tp_dev.y;
 321   4                                      pos_temp[cnt][1] = tp_dev.x; 
 322   4                              }
 323   3                              else if(tp_dev.touchtype == 0)
 324   3                              {
 325   4                                      pos_temp[cnt][0] = 4095 - tp_dev.y;
 326   4                                      pos_temp[cnt][1] = 4095 - tp_dev.x; 
 327   4                              }
 328   3                              else if(tp_dev.touchtype == 1)
 329   3                              {
 330   4                                      pos_temp[cnt][0] = tp_dev.y;
 331   4                                      pos_temp[cnt][1] = tp_dev.x; 
 332   4                              }
 333   3                  cnt++;
 334   3                  switch(cnt)
 335   3                              {                          
 336   4                                      case 1:                                          
 337   4                                              tp_drow_touch_point(20,20,TFT_LCD_WHITE);                               //清除点1
 338   4                                              tp_drow_touch_point(lcddev.width-20,20,TFT_LCD_RED);    //画点2
 339   4                                              break;
 340   4                                      case 2:
 341   4                                              tp_drow_touch_point(lcddev.width-20,20,TFT_LCD_WHITE);  //清除点2
 342   4                                              tp_drow_touch_point(20,lcddev.height-20,TFT_LCD_RED);   //画点3
 343   4                                              break;
 344   4                                      case 3:
 345   4                                              tp_drow_touch_point(20,lcddev.height-20,TFT_LCD_WHITE);                 //清除点3
 346   4                                              tp_drow_touch_point(lcddev.width-20,lcddev.height-20,TFT_LCD_RED);      //画点4
 347   4                                              break;
 348   4                                      case 4:  //全部4个点已经得到
 349   4                                  //对边相等
 350   4                                              tem1=fabs(pos_temp[0][0]-pos_temp[1][0]);//x1-x2
 351   4                                              tem2=fabs(pos_temp[0][1]-pos_temp[1][1]);//y1-y2
 352   4                                              tem1*=tem1;
 353   4                                              tem2*=tem2;
 354   4                                              d1=sqrt(tem1+tem2);     //得到1，2的距离
 355   4                                              
 356   4                                              tem1=fabs(pos_temp[2][0]-pos_temp[3][0]);//x3-x4
 357   4                                              tem2=fabs(pos_temp[2][1]-pos_temp[3][1]);//y3-y4
 358   4                                              tem1*=tem1;
 359   4                                              tem2*=tem2;
 360   4                                              d2=sqrt(tem1+tem2);//得到3，4的距离
 361   4                                              fac=(float)d1/d2;
 362   4                                              if(fac<0.95||fac>1.05||d1==0||d2==0)//不合格
 363   4                                              {
 364   5                                                      cnt=0;
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 7   

 365   5                                              tp_drow_touch_point(lcddev.width-20,lcddev.height-20,TFT_LCD_WHITE);    //清除点4
 366   5                                                      tp_drow_touch_point(20,20,TFT_LCD_RED);                                                         //画点一 
 367   5                                                      continue;
 368   5                                              }
 369   4                                              tem1=fabs(pos_temp[0][0]-pos_temp[2][0]);    //x1-x3
 370   4                                              tem2=fabs(pos_temp[0][1]-pos_temp[2][1]);    //y1-y3
 371   4                                              tem1*=tem1;
 372   4                                              tem2*=tem2;
 373   4                                              d1=sqrt(tem1+tem2);//得到1，3的距离
 374   4                                              
 375   4                                              tem1=fabs(pos_temp[1][0]-pos_temp[3][0]);//x2-x4
 376   4                                              tem2=fabs(pos_temp[1][1]-pos_temp[3][1]);//y2-y4
 377   4                                              tem1*=tem1;
 378   4                                              tem2*=tem2;
 379   4                                              d2=sqrt(tem1+tem2);//得到2，4的距离
 380   4                                              fac=(float)d1/d2;
 381   4                                              if(fac<0.95||fac>1.05)//不合格
 382   4                                              {
 383   5                                                      cnt=0;
 384   5                                              tp_drow_touch_point(lcddev.width-20,lcddev.height-20,TFT_LCD_WHITE);    //清除点4
 385   5                                                      tp_drow_touch_point(20,20,TFT_LCD_RED);                                                         //画点1
 386   5                                                      continue;
 387   5                                              }//正确了
 388   4                                                                         
 389   4                                              //对角线相等
 390   4                                              tem1=fabs(pos_temp[1][0]-pos_temp[2][0]);//x1-x3
 391   4                                              tem2=fabs(pos_temp[1][1]-pos_temp[2][1]);//y1-y3
 392   4                                              tem1*=tem1;
 393   4                                              tem2*=tem2;
 394   4                                              d1=sqrt(tem1+tem2);    //得到1，4的距离
 395   4              
 396   4                                              tem1=fabs(pos_temp[0][0]-pos_temp[3][0]);//x2-x4
 397   4                                              tem2=fabs(pos_temp[0][1]-pos_temp[3][1]);//y2-y4
 398   4                                              tem1*=tem1;
 399   4                                              tem2*=tem2;
 400   4                                              d2=sqrt(tem1+tem2);//得到2，3的距离
 401   4                                              fac=(float)d1/d2;
 402   4                                              if(fac<0.95||fac>1.05)//不合格
 403   4                                              {
 404   5                                                      cnt=0;
 405   5                                              tp_drow_touch_point(lcddev.width-20,lcddev.height-20,TFT_LCD_WHITE);    //清除点4
 406   5                                                      tp_drow_touch_point(20,20,TFT_LCD_RED);                                                         //画点1
 407   5                                                      continue;
 408   5                                              }//正确了
 409   4                                              //计算结果
 410   4                                              tp_dev.xfac=(float)(lcddev.width-40)/(pos_temp[1][0]-pos_temp[0][0]);//得到xfac          
 411   4                                              tp_dev.xoff=(lcddev.width-tp_dev.xfac*(pos_temp[1][0]+pos_temp[0][0]))/2;//得到xoff
 412   4                                                        
 413   4                                              tp_dev.yfac=(float)(lcddev.height-40)/(pos_temp[2][1]-pos_temp[0][1]);//得到yfac
 414   4                                              tp_dev.yoff=(lcddev.height-tp_dev.yfac*(pos_temp[2][1]+pos_temp[0][1]))/2;//得到yoff  
 415   4                                              if(fabs(tp_dev.xfac)>2||fabs(tp_dev.yfac)>2)//触屏和预设的相反了
 416   4                                              {
 417   5                                                      cnt=0;
 418   5                                              tp_drow_touch_point(lcddev.width-20,lcddev.height-20,TFT_LCD_WHITE);    //清除点4
 419   5                                                      tp_drow_touch_point(20,20,TFT_LCD_RED);                                                         //画点1
 420   5                                                      tft_lcd_show_string(40,26,"TP Need readjust!",TFT_LCD_RED,TFT_LCD_WHITE,16,1);
 421   5                                                      if(lcddev.id == 0x9340)
 422   5                                                      {
 423   6                                                              lcddev.id = 0;
 424   6                                                              tp_dev.touchtype = 0;
 425   6                                                      }
 426   5                                                      //tp_dev.touchtype=!tp_dev.touchtype;//修改触屏类型                 
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 8   

 427   5                                                      continue;
 428   5                                              }               
 429   4                                              _tft_lcd_point_color=TFT_LCD_BLUE;
 430   4                                              tft_lcd_clear(TFT_LCD_WHITE);//清屏
 431   4                                              tft_lcd_show_string(35,110,"Touch Screen Adjust OK!",TFT_LCD_RED,TFT_LCD_WHITE,16,1);//校正完成
 432   4                                              delay(200);
 433   4                                              //把校准数据写入触摸屏
 434   4                          eeprom_sector_erase(TOUCH_EEPROM_ADDR);
 435   4                                      eeprom_write_float(TOUCH_EEPROM_ADDR,tp_dev.xfac);
 436   4                                              eeprom_write_float(TOUCH_EEPROM_ADDR+sizeof(float),tp_dev.yfac);
 437   4                                              eeprom_write_int(TOUCH_EEPROM_ADDR+2*sizeof(float),tp_dev.xoff);
 438   4                                              eeprom_write_int(TOUCH_EEPROM_ADDR+2*sizeof(float)+sizeof(int),tp_dev.yoff);
 439   4      
 440   4                                              tft_lcd_clear(TFT_LCD_WHITE);//清屏  
 441   4                                              return;//校正完成                                
 442   4                              }
 443   3                  while(touch_read_pressure() > 100);
 444   3                      }
 445   2                      delay(10);
 446   2                      outtime++;
 447   2                      if(outtime>1000)
 448   2                      {
 449   3                  tft_lcd_clear(TFT_LCD_WHITE);
 450   3                              //从存储器中得到校准数据
 451   3                  tp_dev.xfac = eeprom_read_float(TOUCH_EEPROM_ADDR);
 452   3                              tp_dev.yfac = eeprom_read_float(TOUCH_EEPROM_ADDR+sizeof(float));
 453   3                              tp_dev.xoff = eeprom_read_int(TOUCH_EEPROM_ADDR+2*sizeof(float));
 454   3                              tp_dev.yoff = eeprom_read_int(TOUCH_EEPROM_ADDR+2*sizeof(float)+sizeof(int));
 455   3                              return;
 456   3                      } 
 457   2              }            
 458   1      }
 459          
 460          //========================================================================
 461          // 描述: 触摸的初始化函数.
 462          // 参数: t:0,不进入校准程序;其他值:进入校准程序.
 463          // 返回: none.
 464          //========================================================================
 465          void touch_init(uint8 t)
 466          {
 467   1              if(t == 0)      //直接从eeprom中获取校准数据
 468   1              {
 469   2                      tp_dev.xfac = eeprom_read_float(TOUCH_EEPROM_ADDR);
 470   2                      tp_dev.yfac = eeprom_read_float(TOUCH_EEPROM_ADDR+sizeof(float));
 471   2                      tp_dev.xoff = eeprom_read_int(TOUCH_EEPROM_ADDR+2*sizeof(float));
 472   2                      tp_dev.yoff = eeprom_read_int(TOUCH_EEPROM_ADDR+2*sizeof(float)+sizeof(int));           
 473   2              }else{
 474   2                      touch_adjust(); //进入校准程序
 475   2              }
 476   1      }
 477          
 478          //========================================================================
 479          // 描述: 读取触摸的坐标以及压力值.
 480          // 参数: none.
 481          // 返回: 读到的坐标.
 482          //========================================================================
 483          void touch_get_point(uint16 *tspoint)
 484          {
 485   1              uint16 x,y;
 486   1              tp_read_xy2(&x,&y);
 487   1              if(lcddev.id == 0x9341)
 488   1              {
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 9   

 489   2                      //读取X坐标
 490   2                      tspoint[0] = tp_dev.xfac*(y)+tp_dev.xoff;       
 491   2                      //读取Y坐标
 492   2                      tspoint[1] = tp_dev.yfac*(x)+tp_dev.yoff;       
 493   2              }
 494   1              else if(lcddev.id == 0x9340)
 495   1              {
 496   2                      //读取X坐标
 497   2                      tspoint[0] = tp_dev.xfac*(y)+tp_dev.xoff;       
 498   2                      //读取Y坐标
 499   2                      tspoint[1] = tp_dev.yfac*(x)+tp_dev.yoff;       
 500   2              }
 501   1      
 502   1              else if(tp_dev.touchtype == 0)
 503   1              {
 504   2                      //读取X坐标
 505   2                      tspoint[0] = tp_dev.xfac*(4095 - y)+tp_dev.xoff;        
 506   2                      //读取Y坐标
 507   2                      tspoint[1] = tp_dev.yfac*(4095 - x)+tp_dev.yoff;
 508   2              }
 509   1              else if(tp_dev.touchtype == 1)
 510   1              {
 511   2                      //读取X坐标
 512   2                      tspoint[0] = tp_dev.xfac*(4095 - x)+tp_dev.xoff;        
 513   2                      //读取Y坐标
 514   2                      tspoint[1] = tp_dev.yfac*(4095 - y)+tp_dev.yoff;        
 515   2              }
 516   1      
 517   1          //读取压力
 518   1          tspoint[2] = touch_read_pressure();
 519   1      }
 520          
 521          //========================================================================
 522          // 描述: 读取触摸的x坐标.
 523          // 参数: none.
 524          // 返回: 读到的坐标.
 525          //========================================================================
 526          uint16 touch_read_x()   //读取X的坐标
 527          {
 528   1              uint16 x,y;
 529   1              tp_read_xy2(&x,&y);
 530   1              if(lcddev.id == 0x9341)
 531   1              {
 532   2                      //读取X坐标
 533   2                      return (tp_dev.xfac*(y)+tp_dev.xoff);   
 534   2              }
 535   1              else if(tp_dev.touchtype == 0)
 536   1              {
 537   2                      //读取X坐标
 538   2                      return (tp_dev.xfac*(4095 - y)+tp_dev.xoff);    
 539   2              }
 540   1              else if(tp_dev.touchtype == 1)
 541   1              {
 542   2                      //读取X坐标
 543   2                      return (tp_dev.xfac*(4095 - x)+tp_dev.xoff);            
 544   2              }
 545   1              return 0;
 546   1      }
 547          
 548          //========================================================================
 549          // 描述: 读取触摸的y坐标.
 550          // 参数: none.
C51 COMPILER V9.60.0.0   TOUCH                                                             01/08/2021 19:05:40 PAGE 10  

 551          // 返回: 读到的坐标.
 552          //========================================================================
 553          uint16 touch_read_y()   //读取Y的坐标
 554          {
 555   1              uint16 x,y;
 556   1              tp_read_xy2(&x,&y);
 557   1              if(lcddev.id == 0x9341)
 558   1              {
 559   2                      //读取Y坐标
 560   2                      return (tp_dev.yfac*(x)+tp_dev.yoff);   
 561   2              }
 562   1              else if(tp_dev.touchtype == 0)
 563   1              {       
 564   2                      //读取Y坐标
 565   2                      return (tp_dev.yfac*(4095 - x)+tp_dev.yoff);
 566   2              }
 567   1              else if(tp_dev.touchtype == 1)
 568   1              {
 569   2                      //读取Y坐标
 570   2                      return (tp_dev.yfac*(4095 - y)+tp_dev.yoff);            
 571   2              }
 572   1              return 0;
 573   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6427    ----
   CONSTANT SIZE    =     55    ----
   XDATA SIZE       =     18     110
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
